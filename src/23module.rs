fn main23() {
    
}

// module 模块
// 在库类型的package中, 通过mod去创建模块
// 所有模块都定义在lib.rs文件中

// 使用路径引用模块
// 绝对路径: 从包root开始, crate::A::B::方法()
// 相对路径: 从当前模块开始, self::B::方法()  //self、super、crate、模块名
// 同一个模块中的东西, 可以使用{}一次性引入, std::A::{seld,B,C,D}
// 使用*, 引入模块内所有公共项, std:A:* (需要主要跟自己程序中的名称冲突)

// 引用模块受可见性限制
// 如果需要引用一个模块和里面的函数, 则需要确保模块和函数都是pub的

// 结构体和枚举的可见性
// 1. 结构体为pub, 它的所有字段仍然是私有
// 2. 枚举为pub, 它的所有字段为pub

// lib库可以进行功能性拆分, 只需要使用mod关键字引入模块, 使用use引入模块中的函数, 效果和写在同一个文件中一致
// 需要使用目录拆分子模块, 需要建立同名目录, 同时在目录中创建同名.rs文件, 在文件中定义子模块, 然后再在目录中创建子模块文件

// 同名引用
// 1. 只需要通过 模块名::同名, 就可以进行区分
// 2. 使用as 别名, use引入结构体时, 使用as 进行别名命名

// 引入再导出
// 一个模块被引用时, 对于外部它会被设置为私有不可见, 如需要被可见, 可以pub use 模块;

// 使用第三方包
// 修改 cargo.toml文件, 在[dependencies]添加包和版本, 如 rand = "0.8.3"

// 受限可见性: 使一个模块可以在包中可见, 在外部不可见
// 1. 定义一个非pub的父模块, 父模块对子模块都为可见
// 2. 在子模块中定义一个pub的Y, 通过use 引入包根

// pub 意味着可见性无任何限制
// pub(crate) 表示在当前包可见
// pub(self) 在当前模块可见
// pub(super) 在父模块可见
// pub(in <path>) 表示在某个路径代表的模块中可见，其中 path 必须是父模块或者祖先模块