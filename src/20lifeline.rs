fn main20() {
    _life_time();
}

// 悬垂指针: 指的是引用了不该引用的数据(被drop的数据)
fn _life_time() {
    let x = 5;
    let r;

    {
        // let x = 5;
        r = &x; // Rust编译器会通过 借用检查器 对程序生命周期进行检查
    }

    println!("{}", r);
}

// 函数中的生命周期, 在函数中根据不同的条件分别返回两个不同的引用类型, 会因为编辑器不知道返回的那个, 无法推断生命周期报错
// 需要使用生命周期标注语法: 生命周期标注不会改变任何引用的实际作用域
// 1. 使用生命周期参数, 需要先进行声明<'a>
// 2. 如下例子'a = _frist 和 _secound 中声明周期最短的那个, 就可以保证返回值不会形成悬垂指针
fn _mark<'a>(_first: &'a i32, _secound: &'a i32) -> &'a i32 {
    // &i32         一个引用
    // &'a i32      显式生命周期的引用
    // &'a mut i32  显式生命周期的可变引用
    _secound
}

// 结构体中字段类型
// 1. 使用复杂类型, 只需要初始化的时候直接移交所有权
// 2. 使用引用, 需要想好字段的生命周期
struct _Import<'a> {
    part: &'a str, // 初始化时传进的参数的生命周期, 必须比实例的结构体对象活得更久
}

// 生命周期消除: 当函数中生命周期没有发生歧义, 编译器将自动帮助我们进行声明周期标识消除
// 生命周期消除的三条规则
// 1. 每一个引用参数会获得独自的生命周期
// 2. 若只有一个输入生命周期, 那么该生命周期将赋予所有输出生命周期参数
// 3. 若存在多输入生命周期, 且其中一个为&self, 则self的生命周期将赋予所有输出生命周期

// 声明周期约束语法, 'a: 'b 表示'a必须比'b活得更久

// 静态声明周期: 它跟整个程序活得一样久
// 1. 字面量和特征对象
// 2. 遇到解决不到的生命周期标注问题, 可以尝试使用, 看看能否解决

